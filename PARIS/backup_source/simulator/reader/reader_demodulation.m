% *******************************************************************************************************
% Position Aware RFID Systems: The PARIS Simulation Framework
% ***********************************************************
% reader - complex demodulator stage, (re)sampling with reader sampling frequency and quantization
%
%
%
% ***** Copyright / License / Authors *****
% Copyright 2007, 2008, 2009, 2010, 2011 Daniel Arnitz
%   Signal Processing and Speech Communication Laboratory, Graz University of Technology, Austria
%   NXP Semiconductors Austria GmbH Styria, Gratkorn, Austria
% Copyright 2012 Daniel Arnitz
%   Reynolds Lab, Department of Electrical and Computer Engineering, Duke University, USA
%
% This file is part of the PARIS Simulation Framework.
%
% The PARIS Simulation Framework is free software: you can redistribute it and/or modify it under the
% terms of the GNU General Public License as published by the Free Software Foundation, either
% version 3 of the License, or (at your option) any later version.
%
% The PARIS Simulation Framework is distributed in the hope that it will be useful, but WITHOUT ANY
% WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
% See the GNU General Public License for more details.
%
% You should have received a copy of the GNU General Public License along with the PARIS Simulation 
% Framework. If not, see <http://www.gnu.org/licenses/>.
%
%
% ***** Behavior *****
% version = reader_demodulation()
%    Just returns the version number (string).
% Hd = reader_demodulation(settings)
%    Returns the overall (linear) filter object of this function (dfilt).
% sig_bb = reader_demodulation(signal, settings, oscsettings)
%    Demodulates, filters and (re)samples the input signal. The complex (perfect 90 degree phase shift 
%    between I and Q channel mixer signals) mixer signal is generated by READER_OSCILLATOR according 
%    to OSCSETTINGS. Filtering is done by a cascaded second order IIR structure. The signal is quantized
%    assuming a perfect automatic gain control, always resulting in signal min/max-levels of0...100% of 
%    maximum signal ranges. The returned signals can be truncated/zero-padded to SETTINGS.LEN_RS samples.
%    
%
%
% ***** Interface definition *****
% function sig_bb = reader_demodulation(signal, settings, oscsettings)
%    sig_bb        complex baseband signal (@ fs)
%    settings      struct containing demodulator settings
%       .iirord       anti-aliasing filter order
%       .att          stopband attenuation of anti-aliasing filters in dB
%       .fcut         anti-aliasing filter stopband edge frequency in Hz
%       .frs          reader sampling frequency (= new sampling frequency) in Hz
%       .fs           sampling frequency in Hz
%       .q            bits quantization (set to NaN to deactivate)
%       .len_rs       length of output signals in samples @ frs (will be truncated/zero-padded to that length;
%                     set to NaN to deactivate this functionality)
%    oscsettings   struct containing settings for READER_OSCILLATOR (mixer signal)
%
%    sig_bb     complex baseband signal (@ fs)
%                  -> alternatively: filter object (overall dfilt filter structure of this function)
%    internal   struct containing internal values that may be necessary for test purposes
%       .agc_i     gain of AGC for I-channel (re) if quantization is active
%       .agc_q     gain of AGC for Q-channel (im) if quantization is active
%
%
% ***** Changelog *****
% REVISION   DATE         USER        DESCRIPTION (! bugfixes, + addons, - removals, ~ otherwise)
% beta 1.0   2010-03-30   arnitz      ~ initial release
% beta 2.0   2010-09-01   arnitz      ~ testing release (unstable)
% beta 3.0   2012-05-07   arnitz      ~ partial bugfix release
%
%
% ***** Todo *****
% ? output frequency @ 3dB attenuation
%
% *******************************************************************************************************

function [sig_bb, internal] = reader_demodulation(varargin)
version = 'beta 3.0';


% *******************************************************************************************************
% version system

% just return version number
if nargin == 0
   sig_bb = version;
   return
end

% call version system (logs version numbers)
version_system();


% *******************************************************************************************************
% internal settings

% difference of attenuation of AA filters @ frs/2 to settings.att
internalsettings.att_warn     =  3; % dB
internalsettings.att_critwarn = 10; % dB

% gain warnings for quantization
internalsettings.qgain_warn     = 1e3; 
internalsettings.qgain_critwarn = 1e9;


% *******************************************************************************************************
% input parameter checks / prepare input parameters

% number of input parameters
if nargin == 1
   justgauge = true; % just return linear model of this fcn
   settings  = varargin{1};
elseif nargin == 3
   justgauge   = false;
   signal      = varargin{1}(:);
   settings    = varargin{2};
   oscsettings = varargin{3};
else
   criterr('Wrong number of input arguments.');
end

% check contents of settings
%     prepare required data
expected.name = 'settings';
expected.reqfields = {'iirord', 'att', 'fcut', 'frs', 'fs', 'q', 'len_rs'};
%     check
errortext = contentcheck(settings, expected);
%     output
if ~isempty(errortext)
   err('Incomplete settings\n%s', errortext);
end

% oscsettings are not used by this function => not checked here


% *******************************************************************************************************
% IQ demodulator

% generate baseband (anti-aliasing) filters
% ... use zpk and cascaded filter to avoid instability due to coefficient rounding
[z,p,k] = cheby2(settings.iirord, settings.att, settings.fcut*2/settings.fs);
[s,g] = zp2sos(z,p,k);
Hd = dfilt.df1tsos(s,g); 
% figure; freqz(Hd, logspace(1, log10(2*settings.fcut), 1e3), settings.fs); title('IQ DEMODULATOR LOWPASS');

% just return (overall) filter object?
if justgauge
   sig_bb = Hd;
   return
end

% mixers (has to be sin/cos because of mirrors and to reflect real system)
%      create carrier signals for demodulator (perfect 90 degree phase shift)
oscsettings.length = size(signal, 1) / settings.fs;
oscsettings.mode = 'exp';
mixer_signal = reader_oscillator(oscsettings);
%     apply 
sig_bb = complex(real(signal).*real(mixer_signal), -imag(signal).*imag(mixer_signal));

% apply baseband filters
sig_bb = filter(Hd, sig_bb);


% *******************************************************************************************************
% sampling
msg('Sampling with reader sampling frequency: %.2f MHz (downsampling factor %.2f).', ...
   settings.frs/1e6, settings.fs/settings.frs);

% check attenuation of anti-aliasing filter at frs/2
% ... attention: second parameter has to be an array; a scalar s would mean s points!
h = freqz(Hd, [settings.frs/2, settings.frs/2], settings.fs); h = h(1);
%     create messages (settings.att is positive, 20*log10(abs(h)) is negative)
if settings.att + 20*log10(abs(h)) > internalsettings.att_critwarn
   critwarn('Attenuation of anti-aliasing filter at new fs/2 is very low: %.2f dB (set: %.2f dB).',...
      -20*log10(h), settings.att);
elseif settings.att + 20*log10(abs(h)) > internalsettings.att_warn
   warn('Attenuation of anti-aliasing filter at new fs/2 is low: %.2f dB (set: %.2f dB).',...
      -20*log10(h), settings.att);
else
   msg('Attenuation of anti-aliasing filter at new fs/2:  %.2f dB (set: %.2f dB).',...
      -20*log10(h), settings.att);
end

% output equivalent noise bandwidth of anti-aliasing filter
Hd_impres = impz(Hd);
msg('Two-sided equivalent noise bandwidth of AAF: %.2f MHz (cutoff %.2f MHz)', ...
   settings.fs*1e-6 * sum(abs(Hd_impres).^2) / abs(sum(Hd_impres)).^2, settings.fcut*1e-6);

% resampling
sig_bb = sig_bb(round(1:settings.fs/settings.frs:end));

% quantization (if activated)
% ... assume that AGC is able to place smallest value at minimum input voltage of ADC or largest value
%     at maximum input voltage (full swing for all signals without changing DC value) and that the
%     gains of the AGC are perfectly known (removed after quantization)
% ... zero is at 50% value of ADC
if ~isnan(settings.q)
   % get scaling ("automatic gain control = AGC")
   gain.re = 1 / max(abs(real(sig_bb))) * (2^(settings.q-1) - 0.5);
   gain.im = 1 / max(abs(imag(sig_bb))) * (2^(settings.q-1) - 0.5);
   % shift
   shift = 2^(settings.q-1) - 0.5;     
   % scale, quantize, and rescale
   sig_bb = complex((round(real(sig_bb)*gain.re+shift)-shift)/gain.re, (round(imag(sig_bb)*gain.im+shift)-shift)/gain.im);
   % store gains for selftest (original scaling cannot be reconstructed from output because of rounding)
   internal.agc_re = gain.re;
   internal.agc_im = gain.im;
else
   internal.agc_re = NaN;
   internal.agc_im = NaN;
end


% *******************************************************************************************************
% cut/zero-pad to settings.len_rs

% skip this part if requested
if isnan(settings.len_rs)
   return
end

% truncate/zero-pad if necessary and requested
if ~isnan(settings.len_rs)
   if length(sig_bb) > settings.len_rs
      sig_bb = sig_bb(1:settings.len_rs);
   elseif length(sig_bb) < settings.len_rs
      sig_bb = [sig_bb; zeros(settings.len_rs-length(sig_bb), 1)];
   end
end



return
% *******************************************************************************************************
% *******************************************************************************************************
% OLD AND RUSTY / DEBUGGING SNIPPETS

% if ~isnan(settings.q)
%    %     get scaling
%    shift = min(sig_bb);
%    gain  = max(sig_bb) - shift;
%    %     scale, quantize, an rescale
%    sig_bb = round( (sig_bb-shift)/gain*(2^settings.q-1) ) * gain/(2^settings.q-1) + shift;
% end
% 
   
%    figure; hold on;
%    plot(real(sig_bb)*gain.re+shift, 'b');
%    plot(round(real(sig_bb)*gain.re+shift), 'r.-');
%    hold off; grid on;
%    
%    figure; hold on;
%    plot(imag(sig_bb)*gain.re+shift, 'b');
%    plot(round(imag(sig_bb)*gain.re+shift), 'r.-');
%    hold off; grid on;

